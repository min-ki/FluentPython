# Chapter 2 _ 시퀀스

## 2.1 내장 시퀀스 개요
- 파이썬 표준 라이브러리는 C로 구현된 다음과 같은 시퀀스형을 제공
- 컨데이너 시퀀스 : 서로 다른 자료형의 항목들을 담을 수 있음 (list, tuple, collections.deque)
- 균일 시퀀스 : 단 하나의 자료형만 담을 수 있음 (str, bytes, bytearray, memoryview, array.array 형)
- 컨테이너 시퀀스는 객체에 대한 참조를 담고 있으며 객체는 어떠한 자료형도 될 수 있음
- 균일 시퀀스는 객체에 대한 참조 대신 자신의 메모리 공간에 각 항목의 값을 직접 담음
- 따라서, 균일 시퀀스가 메모리를 더 적게 사용하지만, 문자, 바이트, 숫자 등 기본적인 자료형만 저장할 수 있다.

- 가변성에 따라 다음과 같이 분류도 가능
- 가변 시퀀스 : list, bytearray, array.array, collections.deque, memoryview 형
- 불변 시퀀스 : tuple, str, bytes 형

## 2.2 지능형 리스트(리스트 컴프리헨션)과 제너레이터 표현식
- 지능형 리스트 혹은 제너레이터 표현식을 사용하면 시퀀스를 간단히 생성 가능
- 지능형 리스트 구문이 두 줄 이상 넘어가는 경우에는 코드를 분할하거나 for문을 이용해서 작성하는 것이 더 낫다.
- 파이썬에서는 [], {}, () 안에서의 개행이 무시된다. 역슬래시(\)를 사용하지 않고도 여러 줄에 걸쳐 리스트, 지능형 리스트, 제너레이터 표현식, 딕셔너리를 작성할 수 있다.
- 지능형 리스트는 더 이상 메모리를 누수하지 않는다.

### 2.2.2 지능형 리스트와 map()/filter() 비교
- map()과 filter() 함수를 이용해서 수행할 수 있는 작업은 지능형 리스트를 이용해 모두 구현할 수 있다.

### 2.2.4 제너레이터 표현식
- 지능형 리스트를 사용하는 대신에, 다른 생성자에 전달할 리스트를 통째로 만들지 않고 반복자 프로토콜(iterator protocol)을 이용해서 항목을 하나씩 생성하는 제너레이터 표현식은 메모리를 더 적게 사용한다.
- 제너레이터 표현식은 지능형 리스트와 동일한 구문을 사용하지만, 대괄호 대신 괄호를 사용한다.
- 제너레이터를 사용하면 수백만개가 들어있는 리스트를 생성하는 것을 피할 수 있다.

```python
texts = 'abcde'
tuple(ord(text) for text in texts)
```

## 2.3 튜플은 단순한 불변 리스트가 아니다.
- 튜플은 불편 리스트로 사용할 수도 있지만, 필드명이 없는 레코드로도 사용할 수 있다.

### 2.3.1 레코드로서의 튜플
- 튜플은 레코드를 담고 있다.
- 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정
- 튜플을 필드의 집합으로 사용하는 경우에는 항목 수가 고정되어 있고 항목의 순서가 중요하다.
- 튜플 안에서 항목의 위치가 항목의 의미를 나타내므로 튜플을 정렬하면 정보가 파괴된다.
- 튜플은 언패킹 메커니즘 덕분에 레코드로도 잘 작동한다.

### 2.3.2 튜플 언패킹
```python

# 튜플 언패킹
city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)

traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205826')]

# 튜플 언패킹
for passport in sorted(traveler_ids):
    print('%s/%s' % passport)
```

- 튜플 언패킹은 반복 가능한 객체라면 어느 객체든 적용 가능
- 튜플 언패킹을 이용하면 임시 변수를 사용하지 않고도 두 변수의 값을 서로 교환 가능
- 튜플은 편리하지만 레코드로 사용하기에 부족한 점이 있음
- 때로는 필드에 이름을 붙일 필요가 있음

```python
b,a = a,b
```

### 2.3.4 명명된 튜플
- collections.namedtuple() 함수는 필드명과 클래스명을 추가한 튜플의 서브클래스를 생성하는 팩토리 함수로서, 디버깅할 때 유용하다.
- 필드명이 클래스에 저장되므로 namedtuple()로 생성한 객체는 튜플과 동일한 크기의 메모리만 사용한다. 속성을 객체마다 존재하는 __dict__에 저장하지 않으므로 일반적인 객체보다 메모리를 적게 사용한다.
- 네임드 튜플
- 네임드 튜플을 정의하려면 클래스명과 필드명의 리스트 등 총 2개의 매개변수가 필요
- 필드명의 리스트는 반복형 문자열이나 공백으로 구분된 하나의 문자열을 이용해서 지정한다.

```python
from collections import namedtuple

City = namedtuple('City', 'name country population coordinates')

gunsan = City('Gunsan', 'KR', '20', (38.00000, 150.00000))

gunsan.population # 속성에 접근
gunsan.coordinates # 속성에 접근
gunsan[1] # index를 사용하여 접근
```

